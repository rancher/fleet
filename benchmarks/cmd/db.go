package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/rancher/fleet/benchmarks/cmd/parser"

	gm "github.com/onsi/gomega/gmeasure"

	"github.com/onsi/ginkgo/v2/types"
)

// Population has data from all json reports
type Population struct {
	Samples []parser.Sample
}

// loadDB loads all the json files from db folder and parses them.
// The json files are generated by ginkgo --json-report.
//
// To inspect them manually use jq:
//
//	jq '.[0].SpecReports.[].State' < b-2024-11-11_19:15:08.json
//	jq '.[0].SpecReports.[].ReportEntries' < b-2024-11-12_15:25:33.json
//	jq '.[0].SpecReports.[].ReportEntries.[0].Name' < b-2024-11-12_15:25:33.json
func loadDB(db string) (*Population, error) {
	files, err := filepath.Glob(db + "/*.json")
	if err != nil {
		return nil, err
	}

	pop := &Population{}

	for _, file := range files {
		if s, err := loadSampleFile(file); err != nil {
			return nil, err
		} else if s != nil {
			pop.Samples = append(pop.Samples, *s)
		}
	}

	return pop, nil
}

// loadSampleFile loads a single ginkgo json report file
// This loads any measurements from ginkgo measurement, but it has special
// handling for MemDuring and measurements that use the Before/After suffixes.
//
// To generate such a report json run for example:
//
//	ginkgo run --json-report out.json ./benchmarks
func loadSampleFile(file string) (*parser.Sample, error) {
	data, err := os.ReadFile(file)
	if err != nil {
		return nil, err
	}
	reports := []types.Report{}
	err = json.Unmarshal(data, &reports)
	if err != nil {
		fmt.Printf("failed to unmarshal report: %q\n", data)
		return nil, err
	}
	if len(reports) < 1 {
		return nil, nil
	}

	r := (reports)[0]
	if len(r.SpecReports) < 1 {
		return nil, nil
	}
	if r.SpecReports[0].State != types.SpecStatePassed {
		return nil, nil
	}

	s := parser.Sample{
		Experiments: map[string]parser.Experiment{},
		Setup:       map[string]parser.Measurement{},
	}

	fmt.Printf("Loading sample %s\n", file)
	d, err := parser.NewSetup(r.SpecReports, s.Setup)
	if err != nil {
		return nil, err
	}
	s.Description = d

	total, err := parser.NewExperiments(r.SpecReports, s.Experiments)
	if err != nil {
		return nil, err
	}

	s.Setup["TotalDuration"] = parser.Measurement{
		Type:            gm.MeasurementTypeDuration,
		Style:           "{{bold}}",
		PrecisionBundle: gm.DefaultPrecisionBundle,
		Value:           total,
	}

	return &s, nil
}
